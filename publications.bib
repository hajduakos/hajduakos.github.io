@inproceedings{splst2013,
	author     = {\'{A}kos Hajdu and Andr\'as V\"or\"os and Tam\'as Bartha and Zolt\'an M\'artonka},
	title      = {Extensions to the {CEGAR} Approach on {P}etri Nets},
	year       = {2013},
	pages      = {274--288},
	publisher  = {University of Szeged},
	booktitle  = {Proceedings of the 13th Symposium on Programming Languages and Software Tools},
	isbn       = {978-963-306-228-9},
	editor     = {\'{A}kos Kiss},

    type       = {Conference},
    keywords   = {Petri nets, CEGAR},
	url_pdf    = {https://hajduakos.github.io/publications/splst2013.pdf},
	url_link   = {http://www.inf.u-szeged.hu/projectdirs/splst13/splst13proc.pdf},
	url_slides = {http://www.slideshare.net/AkosHajdu/extensions-to-the-cegar-approach-on-petri-nets},
    url_mtmt   = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=2442424},
	abstract   = {Formal verification is becoming more prevalent and often compulsory in the safety-critical system and software development processes. Reachability analysis can provide information about safety and invariant properties of the developed system. However, checking the reachability is a computationally hard problem, especially in the case of asynchronous or infinite state systems. Petri nets are widely used for the modeling and verification of such systems. In this paper we examine a recently published approach for the reachability checking of Petri net markings. We give proofs concerning the completeness and the correctness properties of the algorithm, and we introduce algorithmic improvements. We also extend the algorithm to handle new classes of problems: submarking coverability and reachability of Petri nets with inhibitor arcs.},
}

@article{acta2014,
	author   = {\'{A}kos Hajdu and Andr\'as V\"or\"os and Tam\'as Bartha and Zolt\'an M\'artonka},
	title    = {Extensions to the {CEGAR} Approach on {P}etri Nets},
	year     = {2014},
	pages    = {401--417},
	journal  = {Acta Cybernetica},
	volume   = {21},
	number   = {3},
	issn     = {0324-721X},
	doi      = {10.14232/actacyb.21.3.2014.8},

    type     = {Journal},
    keywords = {Petri nets, CEGAR},
	url_pdf  = {https://hajduakos.github.io/publications/acta2014.pdf},
	url_link = {http://www.inf.u-szeged.hu/actacybernetica/edb/vol21n3/pdf/Hajdu_2014_ActaCybernetica.pdf},
    url_mtmt = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=2735752},
	abstract = {Formal verification is becoming more prevalent and often compulsory in the safety-critical system and software development processes. Reachability analysis can provide information about safety and invariant properties of the developed system. However, checking the reachability is a computationally hard problem, especially in the case of asynchronous or infinite state systems. Petri nets are widely used for the modeling and verification of such systems. In this paper we examine a recently published approach for the reachability checking of Petri net markings. We give proofs concerning the completeness and the correctness properties of the algorithm, and we introduce algorithmic improvements. We also extend the algorithm to handle new classes of problems: submarking coverability and reachability of Petri nets with inhibitor arcs.},
}

@inproceedings{asconikk2014,
	author     = {\'{A}kos Hajdu and R\'obert N\'emet and Szilvia Varr\'o-Gyapay and Andr\'as V\"or\"os},
	title      = {{P}etri Net Based Trajectory Optimization},
	booktitle  = {ASCONIKK 2014: Extended Abstracts. Future Internet Services},
	year       = {2014},
	location   = {Veszpr\'em, Hungary},
	publisher  = {University of Pannonia},
	pages      = {11--19},
	isbn       = {978-963-396-047-9},

    type       = {Conference},
    keywords   = {Petri nets, CEGAR, optimization},
	url_pdf    = {https://hajduakos.github.io/publications/vocal2014.pdf},
	url_link   = {http://nikk.mik.uni-pannon.hu/images/II_final_.pdf},
	url_slides = {http://www.slideshare.net/AkosHajdu/petri-net-based-trajectory-optimization},
    url_mtmt   = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3023145},
	abstract   = {Optimization problems are becoming more prevalent in the design of complex systems. Petri nets are widely used for the modeling of such systems. An optimization problem can be translated to find an optimal trajectory where a cost is assigned to each step. The reachability problem of Petri nets answers whether a given state is reachable from the initial state. However, reachability analysis is a computationally hard problem, especially in the case of asynchronous or infinite state systems. In this paper we examine a recently published algorithm that solves reachability using abstraction methods and we extend this approach to be able to handle optimal trajectory problems.},
}

@incollection{icatpn2015,
	author     = {\'{A}kos Hajdu and Andr\'as V\"or\"os and Tam\'as Bartha},
	title      = {New search strategies for the {P}etri net {CEGAR} approach},
	year       = {2015},
	booktitle  = {Application and Theory of Petri Nets and Concurrency},
	series     = {Lecture Notes in Computer Science},
	volume     = {9115},
	publisher  = {Springer},
	isbn       = {978-3-319-19488-2},
	pages      = {309--328},
	editor     = {Raymond Devillers and Antti Valmari},
	doi        = {10.1007/978-3-319-19488-2_16},

    type       = {Conference},
    keywords   = {Petri nets, CEGAR},
	url_pdf    = {https://hajduakos.github.io/publications/icatpn2015.pdf},
	url_link   = {http://link.springer.com/chapter/10.1007/978-3-319-19488-2_16},
	url_slides = {http://www.slideshare.net/AkosHajdu/new-search-strategies-for-the-petri-net-cegar-approach},
    url_mtmt   = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=2905183},
	abstract   = {Petri nets are a successful formal method for the modeling and verification of asynchronous, concurrent and distributed systems. Reachability analysis can provide important information about the behavior of the model. However, reachability analysis is a computationally hard problem, especially when the state space is infinite. Abstraction-based techniques are often applied to overcome complexity. In this paper we analyze an algorithm, which uses counterexample guided abstraction refinement. This algorithm proved its efficiency on the model checking contest. We examine the algorithm from a theoretical and practical point of view. On the theoretical side, we show that the algorithm cannot decide reachability for relatively simple instances. We propose a new iteration strategy to explore the invariant space, which extends the set of decidable problems. We also give proofs on the theoretical limits of our approach. On the practical side, we examine different search strategies and we present our new, complex strategy with superior performance compared to traditional strategies. Measurements show that our new contributions perform well for traditional benchmark models as well.},
}

@techreport{cern2015,
	author      = {Hajdu, \'{A}kos},
	title       = {Making the {TT}ree{R}eader interface more accessible},
	number      = {CERN-STUDENTS-Note-2015-039},
	year        = {2015},
	month       = {Aug},
	institution = {European Organization for Nuclear Research (CERN)},

    type        = {Tech. rep.},
    keywords    = {CERN},
	url_pdf     = {http://cds.cern.ch/record/2044503/files/report.pdf},
	url_link    = {http://cds.cern.ch/record/2044503},
    url_mtmt    = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3356225},
	abstract    = {The ROOT framework is the main data analysis tool for High Energy Physics. One of its main features is TTree, a collection type enabling efficient analysis on petabytes of data. ROOT has a new interface called TTreeReader to access data in a type-safe and efficient way. This Summer Student project aims at implementing a utility interface to generate source file skeletons as a starting point for the users. This will make the TTreeReader much more accessible for the users of ROOT.},
}

@incollection{forte2016,
	author     = {Hajdu, \'{A}kos and T\'oth, Tam\'as and V\"or\"os, Andr\'as and Majzik, Istv\'an},
	title      = {A Configurable {CEGAR} Framework with Interpolation-based Refinements},
	year       = {2016},
	booktitle  = {Formal Techniques for Distributed Objects, Components and Systems},
	series     = {Lecture Notes in Computer Science},
	volume     = {9688},
	pages      = {158--174},
	publisher  = {Springer},
	isbn       = {978-3-319-39570-8},
	doi        = {10.1007/978-3-319-39570-8_11},
	editor     = {Albert, Elvira and Lanese, Ivan},

    type       = {Conference},
    keywords   = {CEGAR, framework, transition systems},
	url_pdf    = {https://hajduakos.github.io/publications/forte2016.pdf},
	url_link   = {http://link.springer.com/chapter/10.1007/978-3-319-39570-8_11},
	url_slides = {http://www.slideshare.net/AkosHajdu/a-configurable-cegar-framework-with-interpolationbased-refinements},
    url_mtmt   = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3069540},
	abstract   = {Correctness of software components in a distributed system is a key issue to ensure overall reliability. Formal verification techniques such as model checking can show design flaws at early stages of development. Abstraction is a key technique for reducing complexity by hiding information, which is not relevant for verification. Counterexample-Guided Abstraction Refinement (CEGAR) is a verification algorithm that starts from a coarse abstraction and refines it iteratively until the proper precision is obtained. Many abstraction types and refinement strategies exist for systems with different characteristics. In this paper we show how these algorithms can be combined into a configurable CEGAR framework. In our framework we also present a new CEGAR configuration based on a combination of abstractions, being able to perform better for certain models. We demonstrate the use of the framework by comparing several configurations of the algorithms on various problems, identifying their advantages and shortcomings.},
}

@incollection{icatpn2016,
	author    = {V\"or\"os, Andr\'as and Darvas, D\'aniel and Moln\'ar, Vince and Klenik, Attila and Hajdu, \'{A}kos and J\'ambor, Attila and Bartha, Tam\'as and Majzik, Istv\'an},
	title     = {{PetriDotNet} 1.5: Extensible {P}etri Net Editor and Analyser for Education and Research},
	year      = {2016},
	booktitle = {Application and Theory of Petri Nets and Concurrency},
	series    = {Lecture Notes in Computer Science},
	volume    = {9698},
	pages     = {123--132},
	publisher = {Springer},
	isbn      = {978-3-319-39086-4},
	doi       = {10.1007/978-3-319-39086-4_9},
	editor    = {Kordon, Fabrice and Moldt, Daniel},

    type      = {Conference},
    keywords  = {Petri nets, framework},
	url_pdf   = {https://hajduakos.github.io/publications/icatpn2016.pdf},
	url_link  = {http://link.springer.com/chapter/10.1007/978-3-319-39086-4_9},
    url_mtmt  = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3057505},
	abstract  = {PetriDotNet is an extensible Petri net editor and analysis tool originally developed to support the education of formal methods. The ease of use and simple extensibility fostered more and more algorithmic developments. Thanks to the continuous interest of developers (especially M.Sc. and Ph.D. students who choose PetriDotNet as the framework of their thesis project), by now PetriDotNet became an analysis platform, providing various cutting-edge model checking algorithms and stochastic analysis algorithms. As a result, industrial application of the tool also emerged in recent years. In this paper we overview the main features and the architecture of PetriDotNet, and compare it with other available tools.},
}

@inproceedings{minisy2017,
    author     = {Hajdu, \'{A}kos and Micskei, Zolt\'an},
    title      = {Exploratory Analysis of the Performance of a Configurable {CEGAR} Framework},
    year       = {2017},
    booktitle  = {Proceedings of the 24th PhD Mini-Symposium},
    location   = {Budapest, Hungary},
    publisher  = {Budapest University of Technology and Economics, Department of Measurement and Information Systems},
    editor     = {Pataki, B\'{e}la},
    pages      = {34--37},
    doi        = {10.5281/zenodo.291895},
    isbn       = {978-963-313-243-2},

    type       = {Local event},
    keywords   = {CEGAR, framework, data analysis},
    url_pdf    = {https://hajduakos.github.io/publications/minisy2017.pdf},
    url_link   = {https://doi.org/10.5281/zenodo.291895},
    url_slides = {http://www.slideshare.net/AkosHajdu/exploratory-analysis-of-the-performance-of-a-configurable-cegar-framework},
    url_mtmt   = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3203886},
    abstract   = {Formal verification techniques can check the correctness of systems in a mathematically precise way. However, their computational complexity often prevents their successful application. The counterexample-guided abstraction refinement (CEGAR) algorithm aims to overcome this problem by automatically building abstractions for the system to reduce its complexity. Previously, we developed a generic CEGAR framework, which incorporates many configurations of the algorithm. In this paper we focus on an exploratory analysis of our framework. We identify parameters of the systems and algorithm configurations, overview some possible analysis methods and present preliminary results. We show that different variants are more efficient for certain tasks and we also describe how the properties of the system and parameters of the algorithm affect the success of verification.},
}

@inproceedings{minisy2017fr,
    author     = {Farkas, Rebeka and Hajdu, \'{A}kos},
    title      = {Activity-Based Abstraction Refinement for Timed Systems},
    year       = {2017},
    booktitle  = {Proceedings of the 24th PhD Mini-Symposium},
    location   = {Budapest, Hungary},
    publisher  = {Budapest University of Technology and Economics, Department of Measurement and Information Systems},
    editor     = {Pataki, B\'{e}la},
    pages      = {18--21},
    doi        = {10.5281/zenodo.291891},
    isbn       = {978-963-313-243-2},

    type       = {Local event},
    keywords   = {CEGAR, timed automata},
    url_pdf    = {https://hajduakos.github.io/publications/minisy2017fr.pdf},
    url_link   = {https://doi.org/10.5281/zenodo.291891},
    url_mtmt   = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3203890},
    abstract   = {Formal analysis of real time systems is important as they are widely used in safety critical domains. Such systems combine discrete behaviours represented by control states and timed behaviours represented by clock variables. The counterexample-guided abstraction refinement (CEGAR) algorithm utilizes the fundamental technique of abstraction to system verification. We propose a CEGAR-based algorithm for reachability analysis of timed systems. The algorithm is specialized to handle the time related behaviours efficiently by introducing a refinement technique tailored specially to clock variables. The performance of the presented algorithm is demonstrated by runtime measurements on models commonly used for benchmarking such algorithms.},
}

@incollection{fesca2017,
    author     = {Czip\'o, Bence and Hajdu, \'{A}kos and T\'oth, Tam\'as and Majzik, Istv\'an},
    year       = {2017},
    title      = {Exploiting Hierarchy in the Abstraction-Based Verification of Statecharts Using SMT Solvers},
    editor     = {Kofro\v{n}, Jan and Tumova, Jana},
    booktitle  = {Proceedings of the 14th International Workshop on Formal Engineering Approaches to Software Components and Architectures},
    series     = {Electronic Proceedings in Theoretical Computer Science},
    volume     = {245},
    publisher  = {Open Publishing Association},
    pages      = {31--45},
    doi        = {10.4204/EPTCS.245.3},
    
    type       = {Workshop},
    keywords   = {CEGAR, statecharts},
    url_pdf    = {https://hajduakos.github.io/publications/fesca2017.pdf},
    url_link   = {http://eptcs.web.cse.unsw.edu.au/paper.cgi?FESCA2017.3},
    url_slides = {http://www.slideshare.net/AkosHajdu/exploiting-hierarchy-in-the-abstractionbased-verification-of-statecharts-using-smt-solvers},
    url_mtmt   = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3203861},
    abstract   = {Statecharts are frequently used as a modeling formalism in the design of state-based systems. Formal verification techniques are also often applied to prove certain properties about the behavior of the system. One of the most efficient techniques for formal verification is Counterexample-Guided Abstraction Refinement (CEGAR), which reduces the complexity of systems by automatically building and refining abstractions. In our paper we present a novel adaptation of the CEGAR approach to hierarchical statechart models. First we introduce an encoding of the statechart to logical formulas that preserves information about the state hierarchy. Based on this encoding we propose abstraction and refinement techniques that utilize the hierarchical structure of statecharts and also handle variables in the model. The encoding allows us to use SMT solvers for the systematic exploration and verification of the abstract model, including also bounded model checking. We demonstrate the applicability and efficiency of our abstraction techniques with measurements on an industry-motivated example.},
}

@incollection{vpt2017,
    author     = {Sallai, Gyula and Hajdu, \'{A}kos and T\'oth, Tam\'as and Micskei, Zolt\'an},
    year       = {2017},
    title      = {Towards Evaluating Size Reduction Techniques for Software Model Checking},
    editor     = {Lisitsa, Alexei and Nemytykh, Andrei P. and Proietti, Maurizio},
    booktitle  = {Proceedings of the Fifth International Workshop on Verification and Program Transformation},
    series     = {Electronic Proceedings in Theoretical Computer Science},
    volume     = {253},
    publisher  = {Open Publishing Association},
    pages      = {75--91},
    doi        = {10.4204/EPTCS.253.7},
    
    type       = {Workshop},
    keywords   = {software, reduction, CEGAR, data analysis},
    url_pdf    = {https://hajduakos.github.io/publications/vpt2017.pdf},
    url_link   = {http://eptcs.web.cse.unsw.edu.au/paper.cgi?VPT2017.7},
    url_slides = {http://www.slideshare.net/AkosHajdu/towards-evaluating-size-reduction-techniques-for-software-model-checking},
    url_mtmt = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3229175},
    abstract   = {Formal verification techniques are widely used for detecting design flaws in software systems. Formal verification can be done by transforming an already implemented source code to a formal model and attempting to prove certain properties of the model (e.g. that no erroneous state can occur during execution). Unfortunately, transformations from source code to a formal model often yield large and complex models, making the verification process inefficient and costly. In order to reduce the size of the resulting model, optimization transformations can be used. Such optimizations include common algorithms known from compiler design and different program slicing techniques. Our paper describes a framework for transforming C programs to a formal model, enhanced by various optimizations for size reduction. We evaluate and compare several optimization algorithms regarding their effect on the size of the model and the efficiency of the verification. Results show that different optimizations are more suitable for certain models, justifying the need for a framework that includes several algorithms.}
}

@article{scp2017,
	author   = {Andr\'as V\"{o}r\"{o}s and D\'aniel Darvas and \'Akos Hajdu and Attila Klenik and Krist\'of Marussy and Vince Moln\'ar and Tam\'as Bartha and Istv\'an Majzik},
	title    = {Industrial Applications of the {P}etri{D}ot{N}et Modelling and Analysis Tool},
	year     = {2018},
	journal  = {Science of Computer Programming},
    volume   = {157},
    pages    = {17--40},
	issn     = {0167-6423},
    doi      = {10.1016/j.scico.2017.09.003},

    type     = {Journal},
    keywords = {Petri nets, framework},
    url_pdf  = {https://hajduakos.github.io/publications/scp2017.pdf},
    url_link = {http://www.sciencedirect.com/science/article/pii/S0167642317301910},
    url_mtmt = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3265337},
    abstract = {Since their invention, Petri nets have provided modelling and analysis methods to support the design of correct, reliable and robust systems. This motivated our work to develop PetriDotNet, a Petri net editor and analysis tool. In this paper we overview the supported modelling formalisms and the analysis methods included in PetriDotNet. Next, we present eight different industrial case studies, demonstrating the wide variety of scenarios where Petri nets and PetriDotNet can help the design, development and analysis of industrial systems. Our original goal with PetriDotNet was to provide an educational tool to our students, however our efforts led to a framework being able to serve both academic and industrial needs.},
}

@inproceedings{fmcad2017,
    author     = {T\'oth, Tam\'as and Hajdu, \'{A}kos and V\"or\"os, Andr\'as and Micskei, Zolt\'an and Majzik, Istv\'an},
    year       = {2017},
    title      = {Theta: a Framework for Abstraction Refinement-Based Model Checking},
    booktitle  = {Proceedings of the 17th Conference on Formal Methods in Computer-Aided Design},
	isbn       = {978-0-9835678-7-5},
    editor     = {Stewart, Daryl and Weissenbacher, Georg},
    pages      = {176--179},
    doi        = {10.23919/FMCAD.2017.8102257},
    
    
    type       = {Conference},
    keywords   = {CEGAR, framework},
    url_pdf    = {https://hajduakos.github.io/publications/fmcad2017.pdf},
    url_link   = {http://www.cs.utexas.edu/users/hunt/FMCAD/FMCAD17/proceedings/},
    url_slides = {https://www.slideshare.net/AkosHajdu/theta-a-framework-for-abstraction-refinementbased-model-checking},
    url_mtmt   = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3266689},
    abstract   = {In this paper, we present Theta, a configurable model checking framework. The goal of the framework is to support the design, execution and evaluation of abstraction refinement-based reachability analysis algorithms for models of different formalisms. It enables the definition of input formalisms, abstract domains, model interpreters, and strategies for abstraction and refinement. Currently it contains front-end support for transition systems, control flow automata and timed automata. The built-in abstract domains include predicates, explicit values, zones and their combinations, along with various refinement strategies implemented for each. The configurability of the framework allows the integration of several abstraction and refinement methods, this way supporting the evaluation of their advantages and shortcomings. We demonstrate the applicability of the framework by use cases for the safety checking of PLC, hardware, C programs and timed automata models.},
}

@inproceedings{minisy2018,
    author     = {Hajdu, \'{A}kos and Micskei, Zolt\'an},
    title      = {A Preliminary Analysis on the Effect of Randomness in a {CEGAR} Framework},
    year       = {2018},
    booktitle  = {Proceedings of the 25th PhD Mini-Symposium},
    location   = {Budapest, Hungary},
    publisher  = {Budapest University of Technology and Economics, Department of Measurement and Information Systems},
    editor     = {Pataki, B\'{e}la},
    pages      = {32--35},
    doi        = {10.5281/zenodo.1219261},
    isbn       = {978-963-313-285-2},
    
    type       = {Local event},
    keywords   = {CEGAR, framework, data analysis},
    url_pdf    = {https://hajduakos.github.io/publications/minisy2018.pdf},
    url_slides = {https://www.slideshare.net/AkosHajdu/a-preliminary-analysis-on-the-effect-of-randomness-in-a-cegar-framework},
    url_mtmt   = {https://vm.mtmt.hu/www/index.php?mode=html&st_on=1&url_on=1&com_on=1&la_on=1&type_on=1&cite_type=3&DocumentID=3360591},
    abstract   = {Formal verification techniques can check the correctness of systems in a mathematically precise way. Counterexample-Guided Abstraction Refinement (CEGAR) is an automatic algorithm that reduces the complexity of systems by constructing and refining abstractions. CEGAR is a generic approach, having many variants and strategies developed over the years. However, as the variants become more and more advanced, one may not be sure whether the performance of a strategy can be attributed to the strategy itself or to other, unintentional factors. In this paper we perform an experiment by evaluating the performance of different strategies while randomizing certain external factors such as the search strategy and variable naming. We show that randomization introduces a great variation in the output metrics, and that in several cases this might even influence whether the algorithm successfully terminates.},
}

@incollection{avocs2018,
    author     = {Farkas, Rebeka and T\'oth, Tam\'as and Hajdu, \'{A}kos and V\"or\"os, Andr\'as},
    title      = {Backward reachability analysis for timed automata with data variables},
    year       = {2018},
    booktitle  = {Proceedings of the 18th International Workshop on Automated Verification of Critical Systems},
    
    editor     = {Pichardie, David and Sighireanu, Mihaela},
    series     = {Electronic Communications of the EASST},
    issn       = {1863-2122},
    volume     = {76},
    publisher  = {EASST},
    pages      = {1--20},
    doi        = {10.14279/tuj.eceasst.76.1076},
    
    
    type       = {Workshop},
    keywords   = {CEGAR, timed automata},
    url_pdf    = {https://hajduakos.github.io/publications/avocs2018.pdf},
    abstract   = {Efficient techniques for reachability analysis of timed automata are zone-based methods that explore the reachable state space from the initial state, and SMT-based methods that perform backward search from the target states. It is also possible to perform backward exploration based on zones, but calculating predecessor states for systems with data variables is computationally expensive, prohibiting the successful application of this approach so far. In this paper we overcome this limitation by combining zone-based backward exploration with the weakest precondition operation for data variables. This combination allows us to handle diagonal constraints efficiently as opposed to zone-based forward search where most approaches require additional operations to ensure correctness. We demonstrate the applicability and compare the efficiency of the algorithm to existing forward exploration approaches by measurements performed on industrial case studies. Although the large number of states often prevents successful verification, we show that data variables can be efficienlty handled by the weakest precondition operation. This way our new approach complements existing techniques.}
}

@inproceedings{minisy2019,
    author     = {Bajkai, Vikt{\'o}ria Dorina and Hajdu, \'{A}kos},
    title      = {Software Model Checking with a Combination of Explicit Values and Predicates},
    year       = {2019},
    booktitle  = {Proceedings of the 26th PhD Mini-Symposium},
    location   = {Budapest, Hungary},
    publisher  = {Budapest University of Technology and Economics, Department of Measurement and Information Systems},
    editor     = {Pataki, B\'{e}la},
    pages      = {4--7},
    isbn       = {978-963-313-314-9},
    doi        = {10.5281/zenodo.2597969},
    
    type       = {Local event},
    keywords   = {CEGAR},
    url_pdf    = {https://hajduakos.github.io/publications/minisy2019.pdf},
    abstract   = {Formal verification techniques can both reveal bugs or prove their absence in programs with a sound mathematical basis. However, their high computational complexity often prevents their application on real-world software. Counterexample-guided abstraction refinement (CEGAR) aims to improve efficiency by automatically constructing and refining abstractions for the program. There are several existing abstract domains, such as explicit-values and predicates, but different abstract domains are suitable for different kinds of software. Therefore, product domains have also emerged, which combine different kinds of abstractions in a single algorithm. In this paper, we present a new variant of the CEGAR algorithm, which is a combination of explicit-value analysis and predicate abstraction. We perform an experiment with a wide range of software systems and we compare the results to the existing methods. Measurements show that our new algorithm can efficiently combine the advantages of the different domains.},
}

@incollection{vstte2019,
    author     = {Hajdu, \'Akos and Jovanovi\'c, Dejan},
    title      = {solc-verify: A Modular Verifier for {S}olidity Smart Contracts},
    year       = {2019},
    booktitle  = {Verified Software. Theories, Tools, and Experiments},
    series     = {Lecture Notes in Computer Science},
    volume     = {12301},
    publisher  = {Springer},
    note       = {(Accepted)},

    type       = {Conference},
    url_pdf    = {https://arxiv.org/pdf/1907.04262.pdf},
    url_slides = {https://www.slideshare.net/AkosHajdu/solcverify-a-modular-verifier-for-solidity-smart-contracts},
    abstract   = {We present solc-verify, a source-level verification tool for Ethereum smart contracts. Solc-verify takes smart contracts written in Solidity and discharges verification conditions using modular program analysis and SMT solvers. Built on top of the Solidity compiler, solc-verify reasons at the level of the contract source code, as opposed to the more common approaches that operate at the level of Ethereum bytecode. This enables solc-verify to effectively reason about high-level contract properties while modeling low-level language semantics precisely. The contract properties, such as contract invariants, loop invariants, and function pre- and post-conditions, can be provided as annotations in the code by the developer. This enables automated, yet user-friendly formal verification for smart contracts. We demonstrate solc-verify by examining real-world examples where our tool can effectively find bugs and prove correctness of non-trivial properties with minimal user effort.},
}

@article{jar2019,
	author   = {{\'A}kos Hajdu and Zolt\'an Micskei},
	title    = {Efficient Strategies for {CEGAR}-based Model Checking},
	journal  = {Journal of Automated Reasoning},
    volume   = {Online first},
    year     = {2019},
    doi      = {10.1007/s10817-019-09535-x},

    type     = {Journal},
    keywords = {CEGAR, software},
    url_pdf  = {https://link.springer.com/content/pdf/10.1007%2Fs10817-019-09535-x.pdf},
    abstract = {Automated formal verification is often based on the Counterexample-Guided Abstraction Refinement (CEGAR) approach. Many variants of CEGAR have been developed over the years as different problem domains usually require different strategies for efficient verification. This has lead to generic and configurable CEGAR frameworks, which can incorporate various algorithms. In our paper we propose six novel improvements to different aspects of the CEGAR approach, including both abstraction and refinement. We implement our new contributions in the Theta framework allowing us to compare them with state-of-the-art algorithms. We conduct an experiment on a diverse set of models to address research questions related to the effectiveness and efficiency of our new strategies. Results show that our new contributions perform well in general. Moreover, we highlight certain cases where performance could not be increased or where a remarkable improvement is achieved.},
}

@incollection{esop2020,
    author     = {Hajdu, \'Akos and Jovanovi\'c, Dejan},
    title      = {{SMT}-Friendly Formalization of the {S}olidity Memory Model},
    year       = {2020},
    booktitle  = {Programming Languages and Systems},
    series     = {Lecture Notes in Computer Science},
    volume     = {12075},
    publisher  = {Springer},
    note       = {(Accepted)},

    type       = {Conference},
    url_pdf    = {https://arxiv.org/pdf/2001.03256.pdf},
    abstract   = {Solidity is the dominant programming language for Ethereum smart contracts. This paper presents a high-level formalization of the Solidity language with a focus on the memory model. The presented formalization covers all features of the language related to managing state and memory. In addition, the formalization we provide is effective: all but few features can be encoded in the quantifier-free fragment of standard SMT theories. This enables precise and efficient reasoning about the state of smart contracts written in Solidity. The formalization is implemented in the solc-verify verifier and we provide an extensive set of tests that covers the breadth of the required semantics. We also provide an evaluation on the test set that validates the semantics and shows the novelty of the approach compared to other Solidity-level contract analysis tools. },
}
